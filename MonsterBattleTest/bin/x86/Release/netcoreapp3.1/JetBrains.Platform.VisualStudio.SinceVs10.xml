<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.VisualStudio.SinceVs10</name>
    </assembly>
    <members>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.BuildScript.PreCompile.VsManagedProjectsDevKit10.MefAssemblySimpleName">
            <summary>
            Name of the main MEF assembly, might be used for detecting of MEF-awareness of a project.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.BuildScript.PreCompile.VsManagedProjectsDevKit10.InvalidateMefWhenRebuilding(JetBrains.Application.BuildScript.Solution.AllAssembliesOnEverything,JetBrains.Application.BuildScript.Solution.AllAssembliesOnSources,JetBrains.VsIntegration.BuildScript.InstalledVsVersionsArtifact,JetBrains.Application.BuildScript.ProfileNameArtifact)">
            <summary>
            When a MEF-exposed project gets recompiled, we should mark it as dirty for VS MEF to recalculate its components on startup, otherwise we'd see exceptions and empty editors on the first run.
            This tries to filter MEF-exposed projects (by DLL references) and VS instances which have something in the root suffix named after the current profile.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.BuildScript.PreCompile.VsManagedProjectsDevKit10.EnumMefAwareProjects(System.Collections.Generic.IEnumerable{JetBrains.Application.BuildScript.Solution.SubplatformProjectWrapper})">
            <summary>
            Filters out projects which have refs to MEF assembly. Supposing MEF is only interested in these (at least that's how we filter out assemblies for registering them in VSIX manifest).
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.IDE.VsDocumentManagerWhidbey_TrackVsTextViewDataForTextControlChanges">
            <summary>
            Binds doc man for firing text control re-bind event when document binding changes.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.IDE.VsDocumentManagerWhidbey_TrackVsTextViewDataForTextControlChanges.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.VsIntegration.ProjectDocuments.VsDocumentManagerWhidbey,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges,JetBrains.Application.Threading.IShellLocks)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Declarations.VsEnclosingScopes">
            <summary>
            Microsoft.VisualStudio.Shell.Interop.__VsEnclosingScopes, Microsoft.VisualStudio.Shell.Interop.__VsEnclosingScopes2
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Declarations.VsSettingsScope">
            <summary>
            Microsoft.VisualStudio.Settings.SettingsScope, Microsoft.VisualStudio.Shell.Interop.__VsSettingsScope2
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Declarations.VsSettingsType">
            <summary>
            Microsoft.VisualStudio.Settings.SettingsType
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.GetIVsTextBuffer(Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the adapter to the legacy interface by the new interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.GetIVsTextBuffer(Microsoft.VisualStudio.Text.ITextBuffer,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <summary>
            Gets the adapter to the legacy interface by the new interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.GetTextBuffer(JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the new interface by the legacy interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.TryGetIVsTextBuffer(Microsoft.VisualStudio.Text.ITextBuffer,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Tries to get the adapter to the legacy interface by the new interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.TryGetPathFromTextDocument(Microsoft.VisualStudio.Text.ITextBuffer)">
            <summary>
            Helps with identifying VS buffers.
            In case the underlying document is file-based, extracts its path.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.Documents.ITextBufferEx.TryGetTextBuffer(JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Tries to get the new interface by the legacy interface.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx">
            <summary>
            Extensions to <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView"/> and related things (<see cref="T:Microsoft.VisualStudio.Text.Editor.ITextView"/>, <see cref="T:JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.EnsureOutliningExpanded(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Text.SnapshotPoint,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService})">
            <summary>
            Makes sure that the text control that supports outlining has the specified position expanded.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.EnsureOutliningExpanded(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Text.SnapshotSpan,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService})">
            <summary>
            Makes sure that the text control that supports outlining has the specified span expanded.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetITextView(JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the managed text view from the adapter class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetIVsTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <summary>
            Gets the adapter class that exposes the pre-VS-10 interfaces from the text view.
            DO NOT USE for things that could be achieved thru the modern API!
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetIVsTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the adapter class that exposes the pre-VS-10 interfaces from the text view.
            DO NOT USE for things that could be achieved thru the modern API!
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.TryGetIVsTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the adapter class that exposes the pre-VS-10 interfaces from the text view.
            DO NOT USE for things that could be achieved thru the modern API!
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetServiceProvider(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the Service Provider of the text view.
            It wraps the Visual Studio <see cref="T:Microsoft.VisualStudio.OLE.Interop.IServiceProvider"/> object, but exposes it with the System <see cref="T:System.IServiceProvider"/> API.
            The <see cref="T:Microsoft.VisualStudio.TextManager.Interop.IVsTextView"/>-implementing object is the <c>VsTextViewAdapter</c> who derives from <c>WindowPane</c> who implements the system <see cref="T:System.IServiceProvider"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.TryGetServiceProvider(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the Service Provider of the text view.
            It wraps the Visual Studio <see cref="T:Microsoft.VisualStudio.OLE.Interop.IServiceProvider"/> object, but exposes it with the System <see cref="T:System.IServiceProvider"/> API.
            The <see cref="T:Microsoft.VisualStudio.TextManager.Interop.IVsTextView"/>-implementing object is the <c>VsTextViewAdapter</c> who derives from <c>WindowPane</c> who implements the system <see cref="T:System.IServiceProvider"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetTextViewHost(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the WPF host of the given view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetTextViewHost(JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView)">
            <summary>
            Gets the WPF host of the given view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.GetWindowFrame(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the old-fashioned COM interface for the VS window frame.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.TryGetITextView(JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Tries to get the managed text view from the adapter class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.TryGetWindowFrame(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService)">
            <summary>
            Gets the old-fashioned COM interface for the VS window frame.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.TextControl.IWpfTextViewEx.ToTextBoundsRect(Microsoft.VisualStudio.Text.Formatting.TextBounds)">
            <summary>
            To text-only bounds (not including the full line height).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.GetPropertyByType``1(Microsoft.VisualStudio.Utilities.IPropertyOwner)">
            <summary>
            Gets property keyed by Type. Throws if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.GetPropertyByType``1(Microsoft.VisualStudio.Utilities.IPropertyOwner,System.Func{``0})">
            <summary>
            Gets property keyed by Type. Creates with <paramref name="FCreateIfMissing" /> if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.GetOrCreateLiveProperty``1(Microsoft.VisualStudio.Utilities.IPropertyOwner)">
            <summary>
            Gets a live <see cref="T:JetBrains.DataFlow.IProperty`1" /> property keyed by its value type. Creates with the default ctor.
            </summary>
            <seealso cref="M:JetBrains.VsIntegration.Interop.Shim.TextManager.Documents.IVsTextBuffer.GetOrCreateUserDataProperty``1"/>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.IPropertyOwnerEx.TryGetPropertyByType``1(Microsoft.VisualStudio.Utilities.IPropertyOwner)">
            <summary>
            Gets property keyed by Type. <c>Null</c> if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.SnapshotSpanEx.ContainsFullyInclusive(Microsoft.VisualStudio.Text.SnapshotSpan,Microsoft.VisualStudio.Text.SnapshotPoint)">
            <summary>
            By default, <see cref="M:Microsoft.VisualStudio.Text.SnapshotSpan.Contains(Microsoft.VisualStudio.Text.SnapshotPoint)"/> wouldn't include the end point.
            Include both start and end points.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Extension.SnapshotSpanEx.ContainsFullyExclusive(Microsoft.VisualStudio.Text.SnapshotSpan,Microsoft.VisualStudio.Text.SnapshotSpan)">
            <summary>
            By default, <see cref="M:Microsoft.VisualStudio.Text.SnapshotSpan.Contains(Microsoft.VisualStudio.Text.SnapshotPoint)"/> includes the start point.
            Include both start and end points.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.AsDocLineColumn(Microsoft.VisualStudio.Text.VirtualSnapshotPoint)">
            <summary>
            This method does not perform coordinate conversion. You MUST make sure that <paramref name="vpt"/> is already in the text control coordinate space.
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl"/>::<see cref="P:JetBrains.TextControl.ITextControl.Coords"/> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.AsDocOffsetAndVirtual(Microsoft.VisualStudio.Text.VirtualSnapshotPoint)">
            <summary>
            This method does not perform coordinate conversion. You MUST make sure that <paramref name="vpt"/> is already in the text control coordinate space.
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl"/>::<see cref="P:JetBrains.TextControl.ITextControl.Coords"/> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.AsTextControlLineColumn(Microsoft.VisualStudio.Text.VirtualSnapshotPoint)">
            <summary>
            This method does not perform coordinate conversion. You MUST make sure that <paramref name="vpt"/> is already in the text control coordinate space.
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl"/>::<see cref="P:JetBrains.TextControl.ITextControl.Coords"/> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.MapUpToTop2(Microsoft.VisualStudio.Text.Projection.IBufferGraph,Microsoft.VisualStudio.Text.SnapshotPoint,Microsoft.VisualStudio.Text.PointTrackingMode,Microsoft.VisualStudio.Text.PositionAffinity)">
            <summary>
            Maps the point to the topmost buffer of the graph. Emulates <see cref="T:Microsoft.VisualStudio.Text.Projection.IBufferGraph"/>::<c>MapUpToTop</c> function that were present in Beta1 but was gone in between August and September CTPs.
            </summary>
            <param name="graph">Buffer graph.</param>
            <param name="pointNonTop">A point in some buffer in the <see cref="T:Microsoft.VisualStudio.Text.Projection.IBufferGraph"/>.</param>
            <param name="pointTrackingMode">How <paramref name="pointNonTop"/> is tracked to the current snapshot if necessary.</param>
            <param name="positionAffinity">If the mapping is ambiguous (the position is on a source span seam), determines
                        whether the mapping should target the position immediately after the preceding
                        character or immediately before the following character in the top buffer.
                        This setting has no effect if the mapping is unambiguous.</param>
            <returns>The corresponding position in a snapshot of the top buffer, or null if the position does not map to the top buffer using
                        this graph.</returns>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.ToDocVsVirtualSnapshotPoint(JetBrains.TextControl.Coords.ITextControlPos,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Gets a virtual snapshot point in the document coordinate space.
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl"/>::<see cref="P:JetBrains.TextControl.ITextControl.Coords"/> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.ToVsVirtualSnapshotPoint(JetBrains.TextControl.DocOffsetAndVirtual,Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl"/>::<see cref="P:JetBrains.TextControl.ITextControl.Coords"/> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.ToVsVirtualSnapshotPoint(JetBrains.DocumentModel.DocumentCoords,Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl"/>::<see cref="P:JetBrains.TextControl.ITextControl.Coords"/> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> methods instead.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.TextControl.ConversionDevTen.ToVsVirtualSnapshotPoint(JetBrains.TextControl.TextControlLineColumn,Microsoft.VisualStudio.Text.Editor.ITextView)">
            <summary>
            <para>DO NOT USE this low-level routine unless absolutely sure the surface API will not do.</para>
            <para>Use <see cref="T:JetBrains.TextControl.ITextControl"/>::<see cref="P:JetBrains.TextControl.ITextControl.Coords"/> and <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> methods instead.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.Shim.ShimDynamicApi">
            <summary>
            Temporary class while the API is non-stable. Shims the dynamic things.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Interop.VsFrameMoniker">
            <summary>
            Frame moniker format: "T:I:S:guid", where: 
            ':' is a separator;
            T - frame type: 'D' - document; 'T' - tool window; 'ST' - singleton tool window>; 
            I - instamce ID;
            S - surface ID;
            guid - tool window guid or document window moniker.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.VsModel">
            <summary>
             Raw api to events
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.ConsiderNugetRunningTimeSpan">
            <summary>
            <see cref="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.IsNugetRunningEx"/> is set to true when recent NuGet event happened less than <see cref="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.ConsiderNugetRunningTimeSpan"/>
            2000ms by default
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.ConsiderNugetFailedTimeSpan">
            <summary>
            <see cref="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.IsNugetRunningEx"/> is set to false when no NuGet event happened during <see cref="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.ConsiderNugetFailedTimeSpan"/>
            20000ms by default
            <remarks>Required to restore SWA in case of failed nuget installation/uninstallation</remarks>
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.IsNugetRunningEx">
            <summary>
            True when NuGet is running and the recent NuGet event happened during <see cref="P:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocumentsNuget.NugetEventsWrapper.ConsiderNugetRunningTimeSpan"/>>
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.ProjectDocuments.References.Impl.FixReferencesWithoutDescriptorModifier">
            <inheritdoc />
            <summary>
            Explicitly call MsBuild to resolve references to unloaded projects.
            In VisualStudio 2010/ 2012 when unloaded project is referenced, Reference object does not contain path to its output unlike VisualStudio 2010
            see http://youtrack.jetbrains.com/issue/RSRP-329744
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.ApplicationShutdownRequestsSinceVs10">
            <summary>
            Implements VS-specific restart activity.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Diagnostics.AddVsErrorsToLog">
            <summary>
            Receives information on VS exceptions and write it to our log.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Features.Debugger.ExtendedDebuggerHostServer.AttachToRemoteProcess(System.String,System.UInt32)">
            <summary>
            Instructs the debugger to remote attach process attach to the process with the PID <paramref name="pid"/> on machine <paramref name="remoteAddr"/>.
            
            Prerequirement to use this method:
            1. Remote machine should running x86 remote debugger tools (same version as debugger client) as administartor account.
            2. Credentials for target machine should be saved in windows generic credential store or you should have opened net use connection to this computer.
            </summary>
            <param name="pid"></param>
            <param name="remoteAddr"></param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper">
            <summary>
            Provides methods to register VS extensions.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsInstaller.EnableExtensionsOnLocalInstallStep(JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.VsIntegration.Shell.Build.VsEnvironmentInformationArtifact,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper,JetBrains.Util.ILogger)">
            <summary>
            The standard Local Installation step for enabling just the VS extension being installed.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags.ExcludeOwnVersion">
            <summary>
            <para>Don't return the extension of the current version of the current product (only return other versions).</para>
            <para>Note that there might be multiple registrations for this version in different locations, but we cannot know which one is better (or currently running), so either all or non can be included.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags.ExcludePerMachineLocation">
            <summary>
            Don't return per-machine extensions (they're all-users-all-hives).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags.ExcludePerUserPerHiveLocations">
            <summary>
            Don't return per-user-per-hive locations in various appdata folders.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.MsiExtensionManifestInstaller">
            <summary>
            For MSI-based installs of METH-aware products, emits the Extension Manifest to the Bin folder and creates a shortcut to it from the VS InstallDir.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter">
            <summary>
            Writes the VS PkgDef file from the product <see cref="T:JetBrains.Application.Install.InstallationData.InstallationData"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.IsPackageDefFile">
            <summary>
            <see cref="F:JetBrains.Application.Install.InstallationData.InstalledFile.Metadata"/> entry key for files that should be referenced in VSIX Manifest as PackageDef files.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.Install(JetBrains.Application.Install.InstallationData.InstallationData,JetBrains.VsIntegration.Shell.IVsEnvironmentInformation,System.IO.TextWriter,System.Collections.Generic.Dictionary{JetBrains.Application.Install.InstallationData.InstallationMacroName,System.String})">
            <summary>
            Writes the product VS-specific Registry keys that go under the VS Registry hive into the PkgDef file.
            </summary>
            <param name="data">Installation Data.</param>
            <param name="vsenv"></param>
            <param name="writer">The output stream.</param>
            <param name="macrosOverride">Optional override for select <see cref="T:JetBrains.Application.Install.InstallationData.InstallationMacroName"/> macro values.</param>
            <returns>Returns what Registry data could not be put into PkgDef.</returns>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.CollectEntries(JetBrains.Application.Install.InstallationData.InstallationData,JetBrains.VsIntegration.Shell.IVsEnvironmentInformation,System.Collections.Generic.IDictionary{JetBrains.Util.BackSlashSeparatedRelativePath,System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Collect all non-duplicate Registry entries for writing into pkgdef.
            Returns what Registry data could not be put into PkgDef.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.CreatePkgDefMacros(System.Collections.Generic.Dictionary{JetBrains.Application.Install.InstallationData.InstallationMacroName,System.String})">
            <summary>
            In addition to the externally defined macros, adds PkgDef-specific substitutions to be resolved when reading the PkgDef in Visual Studio.
            </summary>
            <param name="macrosOverride"> </param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.FormatForReg(System.Collections.Generic.IDictionary{JetBrains.Util.BackSlashSeparatedRelativePath,System.Collections.Generic.Dictionary{System.String,System.Object}})">
            <summary>
            Prepares entries for writing to the Reg file "as is", converting the values to strings and escaping the strings.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.SubstituteMacros(System.Collections.Generic.IDictionary{JetBrains.Util.BackSlashSeparatedRelativePath,System.Collections.Generic.Dictionary{System.String,System.Object}},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Applies macro substitutions to the entries and prepares them for writing into the REG file.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.WriteReg(System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.String}},System.IO.TextWriter)">
            <summary>
            Dumps the strings that are ready for writing.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros">
            <summary>
            Macros that can be used in the form of <c>$MacroName$</c> within a pkgdef file.
            Taken from the <c>"PkgDef Management Design.docx"</c> classified document.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.AppDataLocalFolder">
            <summary>
            Path to the sub-folder of CSIDL_LOCAL_APPDATA used by this application – based on the user settings root (e.g. “C:\Users\{user}\AppData\Local\VisualStudio\10.0”).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.AppName">
            <summary>
            Name of the Boutique application (not defined for other appids).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.BaseInstallDir">
            <summary>
            Synonym for ShellFolder for backward compatibility.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.CommonFiles">
            <summary>
            Path to the common files folder for the application (i.e., value of CSICL_PROGRAM_FILES_COMMON) (e.g., “C:\ProgramData\VisualStudio\10.0”)
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.HivelessRootKey">
            <summary>
            Same as RootKey, without the HKEY_CURRENT_USER portion.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.MyDocuments">
            <summary>
            Path to the user’s Documents folder (e.g., “C:\Users\{user}\Documents”).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.PackageFolder">
            <summary>
            Folder in which the PkgDef file was found.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.ProgramFiles">
            <summary>
            Parent folder for all program installations (e.g., “C:\Program Files”)
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.RootFolder">
            <summary>
            Path to the root of the application installation; for Visual Studio and the Express SKUs, this is the same as ShellFolder; for Boutique applications (Isolated shell) this is a different folder, specific to the application. In the latter case, the value is read from HKEY_LOCAL_MACHINE\{registry root}\RootFolder.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.RootKey">
            <summary>
            Parent key for all Configuration values (e.g. “HKEY_CURRENT_USER\Software\Microsoft\VisualStudio\10.0_Config”).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.ShellFolder">
            <summary>
            Path to the root of the Visual Studio shell installation; read from HKEY_LOCAL_MACHINE\{registry root}\InstallDir; for Portable SKUs, this is computed by removing the last two levels of the path to the executable or by applying the rule specified by RelativeRootFolderPath.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.System">
            <summary>
            Windows\System32 directory.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.PackageDefWriter.PkgDefMacros.WinDir">
            <summary>
            Windows installation directory
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.RegistryToPackageDefConverter">
            <summary>
            When emitting for vs10+, turns VS-related Registry installation data into a Package Def file.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsIntegrationPaths">
            <summary>
            Common paths for installing VS-integration-related things.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsIntegrationPaths.GetExtensionFolderRelPath(JetBrains.Application.BuildScript.Application.HostInfo)">
            <summary>
            Gets the path to the folder into which the LNK files to R# VSIX Manifest and PkgDef (or the files themselves) are installed in per-machine or per-user installation scenario.
            Per-machine: the path is relative to the VS installdir, which is what's written into Registry by VS, and it points to the "IDE" folder not the very VS installation root.
            Per-user: the path is relative to the VS LocalAppData hive-specific folder.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsIntegrationPaths.GetProductBinariesVsSpecificRelPath(JetBrains.VsIntegration.Shell.IVsEnvironmentInformation)">
            <summary>
            Gets the relative path (based on product binaries dir) to the compile-time folder under product binaries which contains vs-version-specific things.
            Might be used as a relative path on the target system also.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsIntegrationPaths.GetProductBinariesVsSpecificRelPath(System.Version)">
            <summary>
            Gets the relative path (based on product binaries dir) to the compile-time folder under product binaries which contains vs-version-specific things.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.AdjustExtensionToRunPerUser(JetBrains.Util.FileSystemPath,JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.VsIntegration.Shell.IVsEnvironmentInformation,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper)">
            <summary>
            A per-machine extension is enabled by default, but a per-user must be augmented.
            This includes both modifying the extension manifest and telling extman it's enabled.
            </summary>
            <param name="pathManifest">Path to the extension manifest file. Use <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.FindExtensionManifest(JetBrains.Util.FileSystemPath)" /> if you got just a folder.</param>
            <param name="hostInfo">Env.</param>
            <param name="vsenv">Visual Studio hive identification.</param>
            <param name="vsreg"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.EnableExtensionInRegistry(JetBrains.Util.FileSystemPath,JetBrains.VsIntegration.Shell.IVsEnvironmentInformation,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper)">
            <summary>
            Writes the Registry information so that Visual Studio treated the extension as being enabled.
            </summary>
            <param name="pathExtensionFolder">Path to the folder containing the extension.</param>
            <param name="vsenv">Visual Studio hive identification.</param>
            <param name="reghelp"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.FindAllCompanyExtensionsInHive(JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags,JetBrains.VsIntegration.Shell.IVsEnvironmentInformation)">
            <summary>
            Finds all extensions by this company in the extensions folders for this VS version.
            </summary>
            <param name="exclusionflags"> </param>
            <param name="vsenv">Visual Studio hive identification.</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.FindExtensionManifest(JetBrains.Util.FileSystemPath)">
            <summary>
            In the extension folder, looks for the manifest. Or a shell link to the manifest, in which case it's resolved to the target.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixHelper.LocalEnableCompanyVsExtensions(JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.VsIntegration.Shell.IVsEnvironmentInformation,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsExtensionsBuildHelper)">
            <summary>
            The standard Local Installation step for enabling all of our extensions in VS.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter">
            <summary>
            Produces a VSIX Manifest XML File for the product.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.ourSupportedVsEditions">
            <summary>
            VS editions for vsixmanifest version 1.0
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.ourInstallationTargets">
            <summary>
            Installation targets for vsixmanifest version 2.0
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.WriteVsixManifest(System.Xml.XmlWriter,JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.Application.BuildScript.BuildVersionSuffix,JetBrains.VsIntegration.Shell.Install.VsEnvironmentZoneForBuild,System.Uri,System.Uri,System.Uri,System.Uri,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode,JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackagesEx,JetBrains.Application.BuildScript.ProductPartCatalogForBuild)">
            <summary>
            Produces a VSIX Manifest XML File for the product. Supported by all known VS versions (10.0..15.X).
            </summary>
            <param name="uriPartPreview">Part URI.</param>
            <param name="writer">Writer for the XML output.</param>
            <param name="applicationHost"></param>
            <param name="buildVersionSuffix"></param>
            <param name="vsenvzone"></param>
            <param name="uriPartPkgDef">Path to the PkgDef file that should be referenced in the manifest. Must be relative to the root of the future VSIX container, ie a relative pack part path.</param>
            <param name="uriPartIcon">Part URI.</param>
            <param name="uriPartLicense">Part URI.</param>
            <param name="deploymentmode">Whether we're generating a manifest for the product installed MSI-way, where the manifest is needed for enabling MEF only. <c>False</c> means we're writing the standalone VSIX file.</param>
            <param name="allassPkg"></param>
            <param name="partcatalog">Allows to tell which assemblies might be using MEF and should be registered with VS as MEFable — catalogs have cached info on assembly references and do not require re-analyzing assemblies.</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.WriteVsixManifest20(System.Xml.XmlWriter,JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.Application.BuildScript.BuildVersionSuffix,JetBrains.VsIntegration.Shell.Install.VsEnvironmentZoneForBuild,JetBrains.Util.RelativePath,System.Uri,System.Uri,System.Uri,JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode,JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackagesEx,JetBrains.Application.BuildScript.ProductPartCatalogForBuild,System.Collections.Generic.IEnumerable{JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsdConfigArtifact})">
            <summary>
            Produces an extension.vsixmanifest file version 2.0 supported since VS 11.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.GetFileNameOfProductAssembly(JetBrains.Metadata.Utils.IAssemblyItem)">
            <summary>
            Gets the disk filename for an assembly. Usually it's the assname + extension, but the extension might vary (.dll/.exe) and has to be specified exactly as on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.GetMefAssemblyItems(JetBrains.Application.BuildScript.Solution.AllAssembliesOnPackagesEx,JetBrains.Application.BuildScript.ProductPartCatalogForBuild,JetBrains.VsIntegration.Shell.Install.VsEnvironmentZoneForBuild)">
            <summary>
            Lists assemblies to be inspected by VS in search of MEF components.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode.Msi">
            <summary>
            Packaged into MSI.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode.Manual">
            <summary>
            Just copied manually.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.DeploymentMode.Vsix">
            <summary>
            Packaged into VSIX.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.Elem._N">
            <summary>
            Embeds XML namespace into the element names, to ensure we always use them namespaced.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.VsixManifestWriter.XsdBoolean">
            <summary>
            Matches what XSD thinks to be a boolean constant.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector">
            <summary>
            Provides wrapper around WMI security center interface to query information about antiviruses
            </summary>
            <remarks>
             WMI subsystem can throw <exception cref="T:System.AccessViolationException" /> if access policy forbid access to it, you
             have process them in clients yourself.
            </remarks>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector.QueryAntiviruses">
             <summary>
             Query WMI interface for antiviruses
            
             NOTE: Windows 7 doesn't not consider Defender as an antivirus. Only custom installed products will be listed here.
             </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector.QueryDefenderPreferences">
            <summary>
            Query Windows Defender settings
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector.TryGetPrimaryAntivirus">
            <summary>
            Get single enabled antivirus 
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.AntivirusDetector.AVState">
            <summary>
            Describes state of installed antivirus
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.PerformanceGuideSettingsPageView">
            <summary>
            PerformanceGuideSettingsPageView
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.PerformanceGuide.PerformanceGuideSettingsPageView.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser">
            <summary>
            In Internal mode, suggests turning a per-machine install into a per-user one.
            This is needed to have more than one hive: starting with DevTen, per-machine components can only be registered for ALL hives at once.
            This code takes the product shortcuts installed into <c>Common7\IDE\Extensions</c> and relocates them to <c>%LOCALAPPDATA%\Microsoft\VisualStudio\10.0\Extensions</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.AskCleanupInstallationsByOtherVersions">
            <summary>
            Checks if there are any extensions of the same product but different version registered into the same hive.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.AskJump">
            <summary>
            Asks whether to jump. Returns whether a jump was needed (if dialog will be shown, returns before actually doing the jump, and the jump could then be canceled by the user).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.DoIfNotJumping">
            <summary>
            Called by <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.AskJump"/> when it's decided (by logic or user) not to jump.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.DoJumpWithUI">
            <summary>
            User chose to jump (or we did it automatically). Error handling in UI.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.Jump_CleanupAllPerHiveExtensionsInThisHive(JetBrains.Application.IApplicationHost,JetBrains.VsIntegration.Shell.IVsEnvironmentInformation)">
            <summary>
            Before doing a jump, delete all possible per-hive extensions in this hive.
            More aggressive than <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.AskCleanupInstallationsByOtherVersions"/>.
            </summary>
            <param name="applicationHost"> </param>
            <param name="vsenv"> </param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Local.JumpVsixFromMachineToPerUser.GetExtensionsInHive(JetBrains.Platform.VisualStudio.SinceVs10.Shell.Install.ExclusionFlags,JetBrains.Application.BuildScript.Application.HostInfo,JetBrains.VsIntegration.Shell.IVsEnvironmentInformation)">
            <summary>
            Looks for any extensions of a different version in the same hive.
            </summary>
            <param name="exclusionflags">What to exclude from enumeration.</param>
            <param name="hostInfo">AppDesc.</param>
            <param name="vsenv">Visual Studio hive identification.</param>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.VsMainWindowSinceVs10.MainWpfWindow">
            <summary>
            Gets the main window of the application as a WPF <see cref="T:System.Windows.Window"/> object.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.Shell.VsMainWindowSinceVs10.ActiveWpfWindow">
            <summary>
            An active VS top level window: main or floating tab well or floating tool window.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.Zones.ISinceVs10EnvZone">
            <summary>
            Visual Studio integrated products, VS 10.0 and above.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.VsSkipFirstLaunchSetupProductCanBeStarted">
            <summary>
            On first startup, newer versions of VS might be spawning a secondary instance to have it perform certain one-time tasks.
            Our product shell should not be started up in these instances, because they're considered user-invisible, and our dialogs like licensing are unexpected in this mode.
            To detect the state, we're reading the FirstLaunchSetup VS cmdline parameter, as suggested by MSFT (maybe there's a better method, but we don't know of one yet.
            </summary>
            <remarks>NP-939 Product Shell Should Not Be Started in "FirstLaunchSetup" Mode</remarks>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.IVsServiceProviderEx">
            <summary>
            VS-10-specific extensions to the OLE <see cref="T:Microsoft.VisualStudio.OLE.Interop.IServiceProvider"/> interface.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.Shell.IVsServiceProviderEx.IComponentModel(Microsoft.VisualStudio.OLE.Interop.IServiceProvider)">
            <summary>
            Gets the MEF component model root in VS 10.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.MethTest.IMethTestServer">
            <summary>
            Detects broken installations.
            Now R# in DevTen consists of two separate things: VS Package and VS MEF extension. The first is the main one, but the second is required for normal operation. It's possible that one of them would fail. We consider the VS Package failure to load to be uncommon and fatal, whilst MEF would have its quirks from time to time. These situations we would like to explicitly detect and report, otherwise the symptoms could be ambiguous.
            This is the "server" part: an interface to the component registered with MEF, its presence to be checked by the package when it gets running.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.MethTest.MethTestServer">
            <summary>
            Detects broken installations.
            Now R# in DevTen consists of two separate things: VS Package and VS MEF extension. The first is the main one, but the second is required for normal operation. It's possible that one of them would fail. We consider the VS Package failure to load to be uncommon and fatal, whilst MEF would have its quirks from time to time. These situations we would like to explicitly detect and report, otherwise the symptoms could be ambiguous.
            This is the "server" part: a component registered with MEF, its presence to be checked by the package when it gets running.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.Shell.MethTest.MethTestClient">
            <summary>
            Detects broken installations.
            Now R# in DevTen consists of two separate things: VS Package and VS MEF extension. The first is the main one, but the second is required for normal operation. It's possible that one of them would fail. We consider the VS Package failure to load to be uncommon and fatal, whilst MEF would have its quirks from time to time. These situations we would like to explicitly detect and report, otherwise the symptoms could be ambiguous.
            This is the "client" part: a VS Package component to check the presence of MEF-registered components some time after startup.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChanges">
            <inheritdoc cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges" />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChanges.JetBrains#Platform#VisualStudio#SinceVs10#TextControl#AttachTextControlsToTextViews#ITrackVsTextViewDataForTextControlChanges#TextViewDataChanged">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChangesEx.FireTextViewDataChanged(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks,System.Func{System.Boolean},Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Notifies of the possible change in the view, or any of the existing views if value is NULL.
            Use <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChangesEx.FireTextViewDataChanged(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks,System.Func{System.Boolean},Microsoft.VisualStudio.Text.Editor.IWpfTextView)"/> to fire the change so it works properly with guards and locks.
            there might be a situation when read lock is taken and guard is released. See <see cref="M:JetBrains.VsIntegration.Shell.Actions.Revised.SharedDataContext.AllowSharing(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks)"/>
            </summary>
            <param name="trackVsTextViewDataForTextControlChanges">The interface that fires the signal</param>
            <param name="lifetime">Lifetime for queueing</param>
            <param name="locks">IShellLocks to take guard</param>
            <param name="isEventStillActual">Optional check if signal should be fired (things might be changed when queued)</param>
            <param name="wpfTextView">Optional argument for firing. Null means update all views</param>      
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsAttachTextControlsToTextViews">
            <summary>
            Whenever we see a new text view, create our text control over it.
            We must give a document to the text control, which is normally per-solution, that's why 'tis a solution component.
            Solutionless text controls (eg LT editor) are created elsewhere.
            We hope no text view's buffer has corresponding IDocument in more than one solution :)
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsAttachTextControlsToTextViews.AttachWindowFrameToTextViewRootParent(JetBrains.Lifetimes.Lifetime,JetBrains.Application.UI.WindowManagement.WindowFrame,System.Object,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService,JetBrains.Application.Interop.NativeHook.IWindowsHookManager)">
            <summary>
            We cannot yet rip off information about the window off the <see cref="T:JetBrains.VsIntegration.Interop.Shim.VsShell.Shell.IVsWindowFrame" />.
            Thus, when we're attaching to a VS text control, we only know its <see cref="F:JetBrains.Application.UI.WindowManagement.WindowFrame.RootParentHwnd" /> from the text view.
            </summary>
            <param name="lifetime"></param>
            <param name="frame">Frame of the text control, to be completed with <see cref="F:JetBrains.Application.UI.WindowManagement.WindowFrame.RootParentHwnd" /> info.</param>
            <param name="textview">Text view of either implementation. HWND-based in Whidbey, Avalon-based in DevTen.</param>
            <param name="vsEditorAdaptersFactoryService"></param>
            <param name="hookman"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsAttachTextControlsToTextViews.GetCreateParamsCore(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlDevTen,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService,JetBrains.Application.Interop.NativeHook.IWindowsHookManager,System.Collections.Generic.IEnumerable{JetBrains.Platform.VisualStudio.SinceVs10.TextControl.IFindWindowFrameForVsTextView})">
            <summary>
            Collects env for creating a text control.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen">
            <summary>
            Collects text views, getting them from any possible sources (MEF export collector, RDT events, by enumerating available text views periodically).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen.AdviseViewClosedSafe(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Util.JetWeakReference{JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen})">
            <summary>
            Prevents fucking csc from pulling too many objects into the closure. Should have just the view (which defines the lifetime of all this stuff) and a weak ref to our object (which might live shorter if we're suspended).
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen.VsTextViewsGuarded">
            <summary>
            Lists the VS text controls (views) currently discovered. Guarded.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewCollectorDevTen.GetCurrentVsViewsFromRdt(JetBrains.VsIntegration.Interop.Shim.VsShell.Documents.IRunningDocumentTable,JetBrains.Application.Threading.IThreading,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService},System.Lazy{Microsoft.VisualStudio.TextManager.Interop.IVsTextManager})">
            <summary>
            Enums RDT buffers, then gets text views attached to them.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges">
            <summary>
            Tracks when any VS text view properties change which might need respawning a text control.
            Must be a Shell component.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges.TextViewDataChanged">
            <summary>
            Notifies of the possible change in the view, or any of the existing views if value is NULL.
            Use <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.TrackVsTextViewDataForTextControlChangesEx.FireTextViewDataChanged(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.ITrackVsTextViewDataForTextControlChanges,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks,System.Func{System.Boolean},Microsoft.VisualStudio.Text.Editor.IWpfTextView)" /> to fire the change so it works properly with guards and locks.
            there might be a situation when read lock is taken and guard is released. See <see cref="M:JetBrains.VsIntegration.Shell.Actions.Revised.SharedDataContext.AllowSharing(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.IShellLocks)" />
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlDevTen">
            <summary>
            Based on an <see cref="T:JetBrains.VsIntegration.Interop.Shim.TextManager.TextControl.IVsTextView" />, adds the data which is:
            (1) Sufficient to successfully create a text control over it.
            (2) Uniquely identifies the text control — that is, if this info changes, the text control should be respawned over the same text view.
            The main cause is that out text control strongly binds to the single document
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlCollectorDevTen">
            <summary>
            Maintains a listing of <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlDevTen" />, on which text controls should be created.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewDataForTextControlCollectorDevTen.VsTextViewsWithData">
            <summary>
            Text views which are ready for spawning text controls over them.
            When some crucial property changes for the text control, like a document to be attached to it, an item is revoked from this collection and re-added with new properties, so that the text control could be correctly re-created with the new properties, following the whole text control creation pipeline.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink">
            <summary>
            Monitors vs' creation of text views and maintains the <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink.VsTextViewsUnugarded"/> collection.
            This class is created by MEF, and its lifetime does not agree to the Shell lifetime.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink.VsTextViewsUnugarded">
            <summary>
            Lists the VS text controls (views).
            As this collection directly reflects the VS state, even at times when the Shell is not running, it's not guarded.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.AttachTextControlsToTextViews.VsTextViewSink.Microsoft#VisualStudio#Text#Editor#IWpfTextViewCreationListener#TextViewCreated(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Called when a text view having matchine roles is created over a text data model having a matching content type.
                        Exporters must specify at least one ContentTypeAttribute and one TextViewRole, and should mark their export using the following attribute:
                        [Export(typeof(TextViewCreationListener))], along with [ContentType()] and [TextViewRole()].
            </summary>
            <param name="textView">The newly created text view.</param>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.ContextNotifications.VsContextNotificationHost.CurrentViewCandidates">
            <summary>
            Tracks candidates. Focus events might be out of sync a bit, and we might see more than one at a time.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.ContextNotifications.VsContextNotificationHost.VsContextNotificationHostTextControlComponents.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.ContextNotifications.VsContextNotificationHost,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.TextControl.Transport.TransportTextControl)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.CreateVsTextControlDevTenParams">
            <summary>
            Creates text controls over Visual Studio text views.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.CreateVsTextControlDevTenParams.#ctor(JetBrains.Lifetimes.OuterLifetime,JetBrains.DocumentModel.IDocument,Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Application.UI.WindowManagement.WindowFrame)">
            <summary>
            Creates text controls over Visual Studio text views.
            The text control will be destroyed either when you call <see cref="M:System.IDisposable.Dispose"/> on it or when the text view is unregistered with VS.
            </summary>
            <param name="lifetime">Lifetime for the text control, up until the VS Integration which created it thinks it should be closed.</param>
            <param name="document">The document to be edited by the text control.</param>
            <param name="textview">The Visual Studio text control we're wrapping.</param>
            <param name="frame">Text control frame.</param>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.CreateVsTextControlDevTenParams.Document">
            <summary>
            The document to be edited by the text control.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.CreateVsTextControlDevTenParams.VsTextView">
            <summary>
            The Visual Studio text control we're wrapping.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.GutterMargin.VsGutterMargin">
            <summary>
            The common margin implementation type.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.GutterMargin.VsGutterMarginProvider">
            <summary>
            Bottom standard margin.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.FormatDefinitions.Install.VsPackageEmitsVsClassificationFormatDefinitions">
            <summary>
            Classification definition classes are required to have highlighters in VS10+ text editor.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsGlyphFactory.Microsoft#VisualStudio#Text#Editor#IGlyphFactory#GenerateGlyph(Microsoft.VisualStudio.Text.Formatting.IWpfTextViewLine,Microsoft.VisualStudio.Text.Editor.IGlyphTag)">
            <summary>
            Generates a new glyph visual for the given line.
            </summary>
            <param name="line">The line that this glyph will be placed on.</param><param name="tag">Information about the glyph for which the visual is being generated.</param>
            <returns>
            The visual element for the given tag.
            </returns>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.TagInfoForAdornments.MarkersSingleLinePadding">
            <summary>
            Borrowed from <c>Microsoft.VisualStudio.Text.Utilities.Markers::SingleLinePadding</c>. Used when calculating marker background rect from text boundaries.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.TagInfoForAdornments.EnumSpanGeometries">
            <summary>
            Full text bounds
            This means the full height of the line, including any possible in-line adornments, like in VS12beta
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.TagInfoForAdornments.EnumTextGeometries(JetBrains.Util.dataStructures.FrugalLocalList{System.Windows.Rect}@,System.Boolean)">
            <summary>
            This includes only the text glyphs, not any space allocated within the text view line for in-line adornments, like in VS12beta.
            This also does not include the whitespace in the beginning of the line.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.TagInfoForAdornments.MakeOutlineGeometry">
            <summary>
            Makes an outline geometry for the tag.
            Basically, it's a minimum spanning rect. But it must have cuts on the first and the last lines, to let out anything not falling into the span (example: java-style braces).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.TagInfoForAdornments.GetSignificantTextBounds(Microsoft.VisualStudio.Text.Formatting.ITextViewLine,Microsoft.VisualStudio.Text.SnapshotSpan,System.Boolean,System.Boolean,JetBrains.Util.dataStructures.FrugalLocalList{System.Windows.Rect}@,JetBrains.Util.dataStructures.FrugalLocalList{System.Windows.Rect}@,System.Boolean,System.Boolean)">
            <summary>
            Bounds of covered text, leading/tail whitespace excluded.
            </summary>
            <param name="line">Current text control line (not document line!).</param>
            <param name="spanTagMultiline">The whole tag (might cover many lines), we're analyzing only one line here.</param>
            <param name="isLineFirst">For rects height (text only / fill to adjacent line).</param>
            <param name="isLineLast">For rects height (text only / fill to adjacent line).</param>
            <param name="boundrects">Filled with rects with text covered with span.</param>
            <param name="rectsWithExcludedNonWhitespaceChars">Optionally fills with rects of all non-edge-wsp chars in this line not covered with our span.</param>
            <param name="isCollectingExcludedNonWhitespaceChars">Whether to fill prev param. If <c>False</c>, safe to pass the same list twice, won't touch the second one.</param>
            <param name="skipWhitespaceChars">Skip whitespace characters if true</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsDocumentMarkupDevTen.IsInSync">
            <summary>
            Document may be not synchronized with the host document (VS). In this case we cannot handle this change correctly in
            objects that operate on VS document (like VS Tagger).
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsDocumentMarkupTagger">
            <summary>
            Tagger provided to VS by <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsDocumentMarkupTaggerProvider"/>.
            </summary>
            <remarks>
            The tagger has no lifetime, and should survive R# suspend/resume.
            <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsDocumentMarkupTaggerComponent"/> is used to connect the tagger to R# component model.
            </remarks>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsDocumentMarkupTaggerComponent">
            <summary>
            Serves Shell components which the VS Tagger (a MEF component itself) needs, by exposing them on all text buffers which the tagger might possibly need.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsHighlighterClassificationHelper">
            <summary>
            Helps with conversion between our <see cref="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute"/> and <see cref="T:Microsoft.VisualStudio.Text.Classification.ClassificationFormatDefinition"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Markup.VsHighlightingViewListener.Microsoft#VisualStudio#Text#Editor#IWpfTextViewCreationListener#TextViewCreated(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Called when a text view having matchine roles is created over a text data model having a matching content type.
                        Exporters must specify at least one ContentTypeAttribute and one TextViewRole, and should mark their export using the following attribute:
                        [Export(typeof(TextViewCreationListener))], along with [ContentType()] and [TextViewRole()].
            </summary>
            <param name="textView">The newly created text view.</param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.FindWindowFrameViaTextViewServiceProvider">
            <summary>
            For most text views, their window frame is but a wrapper over the VS Window Frame representing a document tab.
            Get it out of the servide provider on the VS wrapper of the WPF text view.
            VS 10–11: We skip attaching text controls without frames, those should be handled manually, otherwise we do not have full context (eg a DevTen text control locally (bypassing RDT), eg in a refactoring preview, will not have a VS window frame — ok to skip here).
            VS 12: Here we got the new “Embedded Peek Text View” inserted as an island inside a big text view, which we also would like to treat as a text control, and it actually does not have a VS Window Frame on its own — we should execute special operations for finding its window frame.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.IFindWindowFrameForVsTextView">
            <summary>
            For most text views, their window frame is but a wrapper over the VS Window Frame representing a document tab. But sometimes it gets complicated.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.IFindWindowFrameForVsTextView.TryFindWindowFrameForVsTextView(JetBrains.Lifetimes.Lifetime,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            For most text views, their window frame is but a wrapper over the VS Window Frame representing a document tab. But sometimes it gets complicated.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.IVsTextControlCommandExecutingInsideVsNotifySink.OnCommandExecutingInsideVs(JetBrains.Lifetimes.Lifetime,System.ComponentModel.Design.CommandID)">
            <summary>
            Called when a text editor command (for typing or not) is being executed inside the VS implementation.
            This happens when either we do not intercept this sort of commands, or if none of the action/typing handlers cancels it and it reaches the point when it's given back to VS for processing.
            Usually the former (ie there's no <see cref="T:JetBrains.Application.UI.ActionSystem.Text.TextControlActions.ActionIds" /> for that VS command in our model), because if the latter you can get the same event by registering a typing/action handler.
            </summary>
            <param name="lifetime">The lifetime while we are inside the VS' execution.</param>
            <param name="commandid">ID of the VS Command.</param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlAdvertisePackageEntityOnMefEntity">
            <summary>
            When we're ready (and until we begin teardown), advertise the jet model object (running as part of our VS Package) on the VS model object (running as part of MEF graph).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlIsPositionInTextView.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlCommands">
            <summary>
            Integrates with commanding subsystem on the DevTen text control: plugs into the OLE Command Target and wires intercepted commands into Action System Action Handlers or Typing Handlers, depending on the command kind.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlCommands.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget,JetBrains.Application.CommandProcessing.ICommandProcessor,JetBrains.Application.Threading.IShellLocks,System.Collections.Generic.IEnumerable{JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.IVsTextControlCommandExecutingInsideVsNotifySink},System.Collections.Generic.IEnumerable{JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.IVsTextControlCommandDelegatingToActionHandlerNotifySink},System.Collections.Generic.IEnumerable{JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.IVsTextControlCommandDelegatingBackToVsNotifySink},JetBrains.Util.ILogger)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlCompoundActions">
            <summary>
            Opens compound actions on the text view when requested with <see cref="M:JetBrains.TextControl.ITextControl.GetUpdateCookie(System.String)" />. Indirectly, this also comes from <see cref="M:JetBrains.Application.CommandProcessing.ICommandProcessor.BeginBatchTextChange(JetBrains.Lifetimes.Lifetime,System.String)" />.
            TODO: consider sinking <see cref="M:JetBrains.Application.CommandProcessing.ICommandProcessor.BeginBatchTextChange(JetBrains.Lifetimes.Lifetime,System.String)" /> directly and hiding <see cref="M:JetBrains.TextControl.ITextControl.GetUpdateCookie(System.String)" /> from the API because this feels like VS-only feature in this sense.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlCompoundActions.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService})">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlGlobalSyncSources">
            <summary>
            Listens to global/common stuff to trigger the Sync-from-VS event.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlGlobalSyncSources.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget">
            <summary>
            Implements an <see cref="T:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget" />, gets inserted into the text control as the first-chance command target (gets reinserted from time to time to ensure still first-chance) to intercept editor commands:
            1) When typing happens, invokes the typing handlers chain. As a last-chance typing handler, calls into the previous command target on this text control.
            2) When a non-typing command is intercepted, if it's a text control action, executes the action. As a last chance action handler, calls into the previous command target on this text control.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.myActiveExecDelegateBackToVsStack">
            <summary>
            Handlers currently fired to interceptor from <see cref="M:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget.Exec(System.Guid@,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)" /> and ready for delegating back to VS.
            It is yet unclear as of whether they can really be nested (usually, VS won't allow nested commands). TODO: try it out
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.myCommandFilterSequence">
            <summary>
            Lifetime for each sequential insertion of <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Promote" />.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.myLocalReentrancyGuardPromote">
            <summary>
            Controls recursion in <see cref="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Promote" />.
            Note: not sure if it actually happens, but were reported in a couple builds.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.InterceptExecuteCommandHandler">
            <summary>
            Client puts here to sink command execution and possibly intercept.
            Why a live property: to lock-out for the single user.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.YieldingCommandExecToVs">
            <summary>
            While we're yielding command execution to the original VS impl, displays that command ID.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Microsoft#VisualStudio#OLE#Interop#IOleCommandTarget#Exec(System.Guid@,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Here we intercept a typing command in the Visual Studio text editor, and give R# the first chance to handle it.
            If R# does not know the command or refuses to handle it, we skip to the next VS Command Filter in the chain.
            If R# takes the command, it has the choice to either handle it fully on its own, or execute before-handlers, then pass execution to VS along the command filters chain, and then execute the after-hanlers.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Exec_IsSkipInterceptionBecauseOfIncrementalSearch">
            <summary>
            Suppress typing handlers when Incremental Search is in operation in the new text view
            NOTE: in Visual InterDev's text view, the incremental search is a hook right in C++ code of the text view, and it just does not get into the OLE Command Target processing
            In the new WPF text view, on the contrary, the incremental search is but another client on the OLE Command Target fitlers chain of the text view
            If we do not suppress the typing handlers, our typing assist will break the incremental search by inserting characters from the search string into the text view (as we'd have a higher priority than it)
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Promote">
            <summary>
            Creates or updates the command filter.
            The goal of calling the Promote perioducally is to keep ourselves as the very first filter in the filters chain (©dsha).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.Microsoft#VisualStudio#OLE#Interop#IOleCommandTarget#QueryStatus(System.Guid@,System.UInt32,Microsoft.VisualStudio.OLE.Interop.OLECMD[],System.IntPtr)">
            <summary>
            We do not change the availablility of commands, we only intercept execution.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.YieldExecToVs(System.ComponentModel.Design.CommandID,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Called either from our <see cref="M:Microsoft.VisualStudio.OLE.Interop.IOleCommandTarget.Exec(System.Guid@,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)" /> directly, or when the interceptor wants to delegate back to the original impl (via <see cref="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.ExecDelegateBackToVs" />)./
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.YieldExecToVsCore(System.ComponentModel.Design.CommandID,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Does yielding to VS, via <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.myOldCommandTarget" />, notifies owner via <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.YieldingCommandExecToVs" />.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOleCommandTarget.ExecDelegateBackToVs">
            <summary>
            When you intercept a command, given to you in case you want to yield execution to the regular implementation.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOptionsDevTen.ShowScrollBarAnnotationsOptionId">
            <summary>
            That's a "forward reference". This option exists since VS12.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOptionsDevTen.EnableFileHealthIndicatorOptionId">
            <summary>
            That's a "forward reference". This option exists since VS16.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlOptionsDevTen.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Application.Threading.IThreading,JetBrains.Util.ILogger)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlScrollingDevTen.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService},JetBrains.Util.ILogger)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlScrollingDevTen.ScrollTo(JetBrains.TextControl.DocOffsetAndVirtual,JetBrains.TextControl.TextControlScrollType,Microsoft.VisualStudio.Text.Editor.IWpfTextView,System.Lazy{Microsoft.VisualStudio.Text.Outlining.IOutliningManagerService},JetBrains.Util.ILogger)">
            <summary>
            Scrolls the view to make the <paramref name="position" /> visible in the viewport, placing it based on the <paramref name="scrolltype" />.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSelectionDevTen.mySyncFromViewToken">
            <summary>
            Change with this token when setting value by syncing from view rather than user's setting the prop to change the view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSelectionDevTen.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncWhenDocChangesArriveIntoTextView">
            <summary>
            When the doc changes, do vs-sync for the important model parts.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncWhenDocChangesArriveIntoTextView.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs">
            <summary>
            All stuff on the text control should sync to VS at certain invoke thru this common place.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Application.Threading.IThreading,JetBrains.Platform.VisualStudio.Protocol.Common.DocumentModel.VsDocumentModelSynchronization,JetBrains.Util.ILogger)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs.RequestSyncIfAliveGuarded">
            <summary>
            A friendly guard must be held.
            Makes a sync if still alive.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs.RequestSyncIfAliveUnguarded">
            <summary>
            Called from unguarded context (won't merge). Would take guard and cause a sync if still alive.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlTypingActions">
            <summary>
            Serves typing actions of the text control interface.
            TODO: this is going to be much rewritten when splitting out of process.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlTypingActions.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.TextControlComponents.VsTextControlSyncToVs,System.Lazy{Microsoft.VisualStudio.Text.Operations.IEditorOperationsFactoryService})">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsCodeEditorDevTen">
            <summary>
            VS text control to be embedded into tool and popup windows.
            </summary>
            <remarks>
            The control works out of the box for VS tool windows, WinForms forms, and WPF windows.
            </remarks>>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsErrorStripeControlDevTen">
            <summary>
            Provides the WPF implementation of the Error Stripe in VS10+.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsErrorStripeControlDevTen.OnGetIndicatorTooltip(System.Object,JetBrains.UI.SrcView.Tooltips.Avalon.GetJetTooltipEventArgs)">
            <summary>
            Handles requests for tooltips.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.IVsTextControlDevTenIncrementalSearchClient">
            <summary>
            Wraps the Visual Studio Incremental Search access.
            In VS10 and VS11 it's implemented differently due to the fact that in VS11 it's been integrated with regular search.
            The component is required to have an override in VS11+.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.IVsTextControlDevTenIncrementalSearchClient.IsVsIncrementalSearchActive(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Gets whether the text view is in the incremental search mode at the moment.
            </summary>
            <param name="wpfTextView"> </param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsErrorStripeLayoutManagerDevTen.InitErrorStripe(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.DocumentModel.IDocument)">
            <summary>
            Wires up together (1) error stripe doc (2) error stripe control (3) text control.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlComponentAttribute">
            <summary>
            Component classes which wire up a <see cref="T:JetBrains.TextControl.Transport.TransportTextControl" /> to an <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView" />.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.DocLineColumn_To_DocOffset(JetBrains.DocumentModel.DocumentCoords,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Uses VS Text Buffer lines.
            </summary>
            <param name="coords"></param>
            <param name="vsTextView"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.DocOffset_To_DocLineColumn(JetBrains.TextControl.DocOffsetAndVirtual,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Uses VS Text Buffer lines.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.TextControlLineColumn_To_Viewport(JetBrains.TextControl.TextControlLineColumn,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            This is the central char-to-pixel conversion method in the DevTen case.
            It has no such immanent thing as canvas coordinate system, only viewport-relative coords are defined with acceptable accuracy.
            The scrolling is probably in lines, and canvas coord depends on the line height of the lines above the view, which is not calculated until they get into the viewport.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.Viewport_To_TextControlLineColumn(System.Windows.Point,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            This is the central pixel-to-char conversion method in the DevTen case.
            It has no such immanent thing as canvas coordinate system, only viewport-relative coords are defined with acceptable accuracy.
            The scrolling is probably in lines, and canvas coord depends on the line height of the lines above the view, which is not calculated until they get into the viewport.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.GetAverageLineHeight(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Lines outside the viewport do not have layout, pixel coordinates, or height values.
            To approximate pixel y-coordinates outside the viewport, we use the average viewport line height.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.GetTextViewLineNumber(Microsoft.VisualStudio.Text.Editor.IWpfTextView,Microsoft.VisualStudio.Text.Formatting.ITextViewLine,Microsoft.VisualStudio.Text.PointTrackingMode)">
            <summary>
            Takes the text view formatted line, maps it to the visual buffer and gets its line number in the visual buffer.
            </summary>
            <param name="textview">The owning text view. Used for getting the visual buffer.</param>
            <param name="line">The formatted line to get the number of.</param>
            <param name="whichend">Whether to try the beginning or the end of the formatted line for the text view line number. They're not mathematically guaranteed to be the same.</param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.GetViewportRectFromTextView(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Calculates the viewport rectangle in canvas coordinates. Exposed by <see cref="P:JetBrains.TextControl.ITextControlScrolling.ViewportRect" />.
            Unguarded (ie updates even when under a guard).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.MapVsVirtualPoint_DocToTextControl(Microsoft.VisualStudio.Text.VirtualSnapshotPoint,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Raw mapping of VS snapshot points. Preserves virtual space.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextControlCoordinateConversionDevTen.MapVsVirtualPoint_TextControlToDoc(Microsoft.VisualStudio.Text.VirtualSnapshotPoint,Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Raw mapping of VS snapshot points. Preserves virtual space.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen">
            <summary>
            A text control pos impl which does not rely on backend stuff like <see cref="T:JetBrains.TextControl.ITextControl" /> and <see cref="T:JetBrains.DocumentModel.IDocument" /> and fully operates on the VS text view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.#ctor(JetBrains.TextControl.DocOffsetAndVirtual,System.Nullable{System.Windows.Rect},Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <summary>
            Inits the position.
            </summary>
            <param name="position">The basic position, now always based on the doc offset + virtual.</param>
            <param name="viewportExact">If originating from exact pixel position, retains that pixel position. Otherwise gets calculated from the pointed char.</param>
            <param name="vsTextView"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.System#IEquatable{JetBrains#TextControl#Coords#ITextControlPos}#Equals(JetBrains.TextControl.Coords.ITextControlPos)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#TextControl">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToCanvas">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToDocLineColumn">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToDocOffset">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToDocOffsetAndVirtual">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToRetainedPos">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToScreen">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewControlPosDevTen.JetBrains#TextControl#Coords#ITextControlPos#ToTextControlLineColumn">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen">
            <summary>
            A text control pos impl which does not rely on backend stuff like <see cref="T:JetBrains.TextControl.ITextControl" /> and <see cref="T:JetBrains.DocumentModel.IDocument" /> and fully operates on the VS text view.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.#ctor(Microsoft.VisualStudio.Text.Editor.IWpfTextView)">
            <param name="vsTextView"></param>
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromCanvas(JetBrains.TextControl.Graphics.PointEx)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromDocLineColumn(JetBrains.DocumentModel.DocumentCoords)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromDocOffset(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromDocOffsetAndVirtual(JetBrains.TextControl.DocOffsetAndVirtual)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromScreen(System.Drawing.Point)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Coordinates.VsTextViewCoordsDevTen.JetBrains#TextControl#Coords#ITextControlCoords#FromTextControlLineColumn(JetBrains.TextControl.TextControlLineColumn)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlCreatorDevTen.CreateTextControl``1(JetBrains.TextControl.CreateTextControlParams{``0})">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlCreatorDevTen.TmpTextControlBackendFrontendMapping">
            <summary>
            <see cref="T:JetBrains.TextControl.ITextControl" /> is a backend-only entity. <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView" /> is a frontend-only entity. For the sake of APIs which mix front-back parts, allows to transition between them.
            These are to be phased out.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlCreatorDevTen.TmpTextControlBackendFrontendMapping.TmpTryTransitionBackToFront(JetBrains.TextControl.ITextControl)">
            <summary>
            <see cref="T:JetBrains.TextControl.ITextControl" /> is a backend-only entity. <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView" /> is a frontend-only entity. For the sake of APIs which mix front-back parts, allows to transition between them.
            These are to be phased out.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy">
            <summary>
            The data class intended to represent our text control instance on the VS side when the code goes out of process.
            Should contain everything we need to attach to a VS text control.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.#ctor(JetBrains.Lifetimes.OuterLifetime,Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.DocumentModel.IDocument,JetBrains.VsIntegration.DocumentModel.Whidbey.VsDocumentWhidbeyEnvoy,JetBrains.Application.UI.WindowManagement.WindowFrame,JetBrains.Application.Threading.IThreading,System.Lazy{Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService},JetBrains.VsIntegration.DocumentModel.Whidbey.IVsDocumentWhidbeyEnvoyRegistry)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.IsVsAlive">
            <summary>
            Gets whether the VS implementation of the text control is currently alive or not.
            The text control is disposed of under a guard, which is much later than the native VS object ceases to exist.
            </summary>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.IsVsDead">
            <summary>
            Gets whether the VS implementation of the text control is already dead or not.
            The text control is disposed of under a guard, which is much later than the native VS object ceases to exist.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.LegacyVsTextBuffer">
            <summary>
            Caches the legacy text buffer object, which is the legacy API conterpart for <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.VsTextView" />'s <see cref="P:Microsoft.VisualStudio.Text.Editor.ITextView.TextBuffer" />.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.LegacyVsTextView">
            <summary>
            Legacy counterpart for the <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.VsTextView" />. Some of the APIs are still only available thru it.
            Worse even, some of the functionality is only implemented on the legacy API wrapping object!
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.Lifetime">
            <summary>
            Guarded disposal of the text control.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.LifetimeUnguarded">
            <summary>
            Dropped immediately as the native window gets closed.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy.VsTextView">
            <summary>
            The Visual Studio text editor main object in the modern API.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenIncrementalSearchClientSinceVs10">
            <summary>
            VS10+ client (NOTE: in VS11+ this <see cref="T:Microsoft.VisualStudio.Text.IncrementalSearch.IIncrementalSearch"/> implementation is present, but is not active).
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlErrorStripeDevTen.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextControlDevTenEnvoy,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsErrorStripeLayoutManagerDevTen)">
            <summary>
            Wires up together (1) error stripe doc (2) error stripe control (3) text control.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextViewShellContext">
            <summary>
            Assigned to the MEF component, exposes the package components.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginDevTenEx.GetMargin(Microsoft.VisualStudio.Text.Editor.IWpfTextView,System.Windows.Controls.Dock)">
            <summary>
            Gets our multi-control-host margin from the text view.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBaseDevTen">
            <summary>
            Base class for standard around-the-editor margins.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBaseDevTen.MarginTextViewRole00">
            <summary>
            Works for most of the views.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBaseDevTen.MarginTextViewRole01">
            <summary>
            Smth new with VS12: a peek view inserted into a larger text view. Requires a separate flag to run a margin inside.
            In older VSes would be silently ignored.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin">
            <summary>
            A dynamic (runtime-defined) margin for the <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextView"/>-kind text control.
            </summary>
        </member>
        <member name="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.myCachedUiElement">
            <summary>
            Create one from the <see cref="F:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.myData"/>, cache from then on.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.#ctor(JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Data)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.AddToTextControl(Microsoft.VisualStudio.Text.Editor.IWpfTextView,JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Data,System.Windows.Controls.Dock,Microsoft.VisualStudio.Editor.IVsEditorAdaptersFactoryService,JetBrains.Application.IApplicationHost)">
            <summary>
            Adds a margin/provider to the text control.
            </summary>
            <param name="textview">The host.</param>
            <param name="data">Describes the margin to be created.</param>
            <param name="dock">The side of the text control to dock the margin at.</param>
            <param name="vsEditorAdaptersFactoryService"></param>
            <param name="applicationDescriptor"></param>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#GetTextViewMargin(System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextViewMargin"/> with the given <paramref name="marginName"/>.
            </summary>
            <param name="marginName">The name of the <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextViewMargin"/>.</param>
            <returns>
            The <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextViewMargin"/> named <paramref name="marginName"/>, or null if no match is found.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="marginName"/> is null.</exception>
            <remarks>
            A margin must return itself if passed its name, and a container margin must forward the call to its children.
            </remarks>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#Enabled">
            <summary>
            Determines whether the margin is enabled.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The margin is disposed.</exception>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Microsoft#VisualStudio#Text#Editor#ITextViewMargin#MarginSize">
            <summary>
            Gets the size of the margin. 
            </summary>
            <remarks>
            For a horizontal margin this is the height of the margin, 
                        since the width will be determined by the <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextView"/>. 
                        For a vertical margin this is the width of the margin, since the height will be determined by the <see cref="T:Microsoft.VisualStudio.Text.Editor.ITextView"/>.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">The margin is disposed.</exception>
        </member>
        <member name="P:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Microsoft#VisualStudio#Text#Editor#IWpfTextViewMargin#VisualElement">
            <summary>
            Gets the FrameworkElement that renders the margin.
            </summary>
            <exception cref="T:System.ObjectDisposedException">if the margin is disposed.</exception>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Data">
            <summary>
            Describes the margin context to be dragged thru the provider and so on.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Data.#ctor(JetBrains.Lifetimes.Lifetime,System.String,System.Double,System.Func{JetBrains.Lifetimes.Lifetime,System.Windows.FrameworkElement})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
            <param name="lifetime"></param>
            <param name="id">Margin name. One can get a margin by its name from the text view.</param>
            <param name="width">Margin width, in logical pixels.</param>
            <param name="FCreateView">Creates the presentation for the new margin, given its lifetime.</param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Provider">
            <summary>
            A provider to create the preconfigured margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Provider.Clone">
            <summary>
            Used in contexts where a <c>Func</c> for creating a provider is required.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlDynamicMargin.Provider.Microsoft#VisualStudio#Text#Editor#IWpfTextViewMarginProvider#CreateMargin(Microsoft.VisualStudio.Text.Editor.IWpfTextViewHost,Microsoft.VisualStudio.Text.Editor.IWpfTextViewMargin)">
            <summary>
            Creates an <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewMargin"/> for the given <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewHost"/>.
            </summary>
            d\
                        <param name="wpfTextViewHost">The <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewHost"/> for which to create the <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewMargin"/>.</param><param name="marginContainer">The margin that will contain the newly-created margin.</param>
            <returns>
            The <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewMargin"/>.  
                        The value may be null if this <see cref="T:Microsoft.VisualStudio.Text.Editor.IWpfTextViewMarginProvider"/> does not participate for this context.
            </returns>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginDevTen">
            <summary>
            The common margin implementation type.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBottomDevTen">
            <summary>
            Bottom standard margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderBottomDevTen.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderLeftDevTen">
            <summary>
            Left standard margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderLeftDevTen.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderRightDevTen">
            <summary>
            Right standard margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderRightDevTen.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderTopDevTen">
            <summary>
            Top standard margin.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.Marginal.VsTextControlMarginProviderTopDevTen.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextViewKeyProcessor">
            <summary>
            Backend for the <see cref="P:JetBrains.TextControl.ITextControlWindow.Keyboard"/> event.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextViewMouseProcessor">
            <summary>
            Backend for the <see cref="P:JetBrains.TextControl.ITextControlWindow.MouseMove" />, <see cref="P:JetBrains.TextControl.ITextControlWindow.MouseDown" />, <see cref="P:JetBrains.TextControl.ITextControlWindow.MouseUp" /> events.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.TextControl.VsTextViewMouseProcessor.Factory">
            <summary>
            Mouse processor factory creates a mouse processor for each VS text view.
            </summary>
            (DK) RSRP-329395 Ctrl+Click does not work.
            The cause of this issue is that our mouse processor did not receive MouseDown/MouseUp events. The root cause is described below.
            Microsoft.VisualStudio.Text.Utilities.WpfMouseProcessor keeps an ordered list of mouse processors and calls them in that order. 
            The code of all its event handlers looks like follows:
            
            public void UIElement_MouseDown(object sender, MouseButtonEventArgs e)
            {
            foreach (IMouseProcessor processor in _mouseProcessors)
            {
            processor.PreprocessMouseDown(e);
            if (e.Handled) break;
            }
            if (!e.Handled)
            this.DefaultMouseDownHandler(sender, e);
            foreach (IMouseProcessor processor in _mouseProcessors)
            processor.PostprocessMouseDown(e);
            }
            
            Furthermore, MSDN says "If you mark MouseLeftButtonDown/MouseRightButtonDown handled, you are essentially marking Mouse.MouseDown handled 
            for all further listeners along the route, and on all related events." 
            
            There are more than 10 mouse processors in VS. The order of the processor depends on [Order(Before|After="Name")] attribute of its factory (IMouseProcessorProvider).
            We cannot ensure that our processor is the first in the list, as we aren't able to know the names of all processors. 
            If at least one of them marks MouseLeftButtonDown as handled we will not receive MouseDown/Up (which we preprocessed before).
            
            The solution is to override POSTprocess of MouseLeft/Right/Down/Up in our VsTextViewMouseProcessor to ensure that we always get mouse events.
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.UI.PublishPlatformResourceDictionaryToAvalonApplicationV4">
            <summary>
            This assembly is compiled for NETFX 4 and has PresentationFramework v4. Register our ResourceDictionary in it.
            </summary>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsAvalonStatusBarShimDevTen">
            <summary>
            An extension to the <see cref="T:JetBrains.UI.Controls.AvalonStatusBarShim"/> class with DevTen-specific functions.
            </summary>
            <seealso cref="T:JetBrains.UI.Controls.AvalonStatusBarShim"/>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsAvalonStatusBarShimDevTen.TrySubclassDevTenBeta2StatusDockPanelInWindow(JetBrains.Lifetimes.Lifetime,System.IntPtr,JetBrains.DataFlow.ICollectionEvents{JetBrains.Application.StdApplicationUI.StatusBars.JetStatusBarIndicator},JetBrains.Application.UI.PopupLayout.IMainWindowPopupWindowContext,JetBrains.Application.UI.Controls.JetPopupMenu.JetPopupMenus,JetBrains.Application.Interop.NativeHook.IWindowsHookManager,JetBrains.Application.UI.Components.Theming.ITheming)">
            <summary>
            Works in DevTen Beta2+ for its status bars, see <see cref="M:JetBrains.UI.Controls.AvalonStatusBarShim.TryFindDevTenBeta2StatusDockPanelInHwnd(System.IntPtr)"/> for comments.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsAvalonStatusBarShimDevTen.SubclassDevTenBeta2StatusDockPanel(JetBrains.Lifetimes.Lifetime,System.Windows.Controls.Panel,JetBrains.DataFlow.ICollectionEvents{JetBrains.Application.StdApplicationUI.StatusBars.JetStatusBarIndicator},JetBrains.Application.UI.PopupLayout.IMainWindowPopupWindowContext,JetBrains.Application.UI.Controls.JetPopupMenu.JetPopupMenus,JetBrains.Application.Interop.NativeHook.IWindowsHookManager,JetBrains.Application.UI.Components.Theming.ITheming)">
            <summary>
            Works in DevTen Beta2+ for its status bars, see <see cref="M:JetBrains.UI.Controls.AvalonStatusBarShim.TryFindDevTenBeta2StatusDockPanelInHwnd(System.IntPtr)"/> for comments.
            </summary>
        </member>
        <member name="M:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsAvalonStatusBarShimDevTen.AddItemsHostToStatusDockPanel(JetBrains.Lifetimes.Lifetime,System.Windows.Controls.Panel,System.Windows.Controls.ItemsControl)">
            <summary>
            Helper for attaching to the status line of a window. Places a panel for our items in between the status bar and resize grip.
            Must be executed on the UI thread.
            </summary>
            <param name="lifetime"></param>
            <param name="statusdock">The dock panel of the window status line.</param>
            <param name="panelToHostOnStatusBar">The Avalon element to put on the status bar as its item.</param>
        </member>
        <member name="T:JetBrains.Platform.VisualStudio.SinceVs10.UI.VsStatusBarIndicatorsDevTen">
            <summary>
            The status bar support part which inserts indicators into the DevEnv status bar by subclassing it as a WPF status bar and inserting own elements.
            </summary>
        </member>
    </members>
</doc>
